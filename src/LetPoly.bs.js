// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var List = require("rescript/lib/js/list.js");
var Caml_obj = require("rescript/lib/js/caml_obj.js");
var Belt_List = require("rescript/lib/js/belt_List.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Belt_SetString = require("rescript/lib/js/belt_SetString.js");

function toString(_t) {
  while(true) {
    var t = _t;
    if (typeof t === "number") {
      if (t === /* TInt */0) {
        return "Int";
      } else {
        return "Bool";
      }
    }
    switch (t.TAG | 0) {
      case /* TVar */0 :
          var sx = t._0.contents;
          if (sx.TAG === /* Nolink */0) {
            return "T_" + sx._0;
          }
          _t = sx._0;
          continue ;
      case /* TArr */1 :
          return "( " + toString(t._0) + " -> " + toString(t._1) + " )";
      case /* QVar */2 :
          return "QT_" + t._0;
      
    }
  };
}

var tvar_cnt = {
  contents: 0
};

function fresh_name(param) {
  tvar_cnt.contents = tvar_cnt.contents + 1 | 0;
  return {
          contents: {
            TAG: /* Nolink */0,
            _0: "@*" + tvar_cnt.contents.toString()
          }
        };
}

function new_tvar(param) {
  return {
          TAG: /* TVar */0,
          _0: fresh_name(undefined)
        };
}

var inst_map = {
  contents: /* [] */0
};

function fresh_inst(qs) {
  var n = Belt_List.getAssoc(inst_map.contents, qs, (function (a, b) {
          return a === b;
        }));
  var inst_cnt = n !== undefined ? n : 0;
  inst_map.contents = Belt_List.setAssoc(inst_map.contents, qs, inst_cnt + 1 | 0, (function (a, b) {
          return a === b;
        }));
  return {
          contents: {
            TAG: /* Nolink */0,
            _0: qs + "_" + (inst_cnt + 1 | 0).toString()
          }
        };
}

function new_inst(qs) {
  return {
          TAG: /* TVar */0,
          _0: fresh_inst(qs)
        };
}

function inst(tp) {
  var get_qvars = function (_t) {
    while(true) {
      var t = _t;
      if (typeof t === "number") {
        return /* [] */0;
      }
      switch (t.TAG | 0) {
        case /* TVar */0 :
            var rv = t._0.contents;
            if (rv.TAG === /* Nolink */0) {
              return /* [] */0;
            }
            _t = rv._0;
            continue ;
        case /* TArr */1 :
            return Belt_List.concatMany([
                        get_qvars(t._0),
                        get_qvars(t._1)
                      ]);
        case /* QVar */2 :
            return {
                    hd: t._0,
                    tl: /* [] */0
                  };
        
      }
    };
  };
  var qvars = Belt_SetString.toList(Belt_SetString.fromArray(Belt_List.toArray(get_qvars(tp))));
  var subst_map = Belt_List.map(qvars, (function (qs) {
          return [
                  qs,
                  {
                    TAG: /* TVar */0,
                    _0: fresh_inst(qs)
                  }
                ];
        }));
  var subst_inst = function (_t, m) {
    while(true) {
      var t = _t;
      if (typeof t === "number") {
        return t;
      }
      switch (t.TAG | 0) {
        case /* TVar */0 :
            var rv = t._0.contents;
            if (rv.TAG === /* Nolink */0) {
              return t;
            }
            _t = rv._0;
            continue ;
        case /* TArr */1 :
            return {
                    TAG: /* TArr */1,
                    _0: subst_inst(t._0, m),
                    _1: subst_inst(t._1, m)
                  };
        case /* QVar */2 :
            var r = Belt_List.getAssoc(m, t._0, (function (a, b) {
                    return a === b;
                  }));
            if (r !== undefined) {
              return r;
            }
            throw {
                  RE_EXN_ID: "Assert_failure",
                  _1: [
                    "LetPoly.res",
                    66,
                    15
                  ],
                  Error: new Error()
                };
        
      }
    };
  };
  return subst_inst(tp, subst_map);
}

function occurs(x, _t) {
  while(true) {
    var t = _t;
    if (typeof t === "number") {
      return false;
    }
    switch (t.TAG | 0) {
      case /* TVar */0 :
          var a = t._0;
          if (Caml_obj.equal(a.contents, x.contents)) {
            return true;
          }
          var t$p = a.contents;
          if (t$p.TAG === /* Nolink */0) {
            return false;
          }
          _t = t$p._0;
          continue ;
      case /* TArr */1 :
          if (occurs(x, t._0)) {
            return true;
          }
          _t = t._1;
          continue ;
      case /* QVar */2 :
          return false;
      
    }
  };
}

function repr_type(t) {
  if (typeof t === "number") {
    return t;
  }
  if (t.TAG !== /* TVar */0) {
    return t;
  }
  var tvar = t._0;
  var t1 = tvar.contents;
  if (t1.TAG === /* Nolink */0) {
    return t;
  }
  var t1$p = repr_type(t1._0);
  tvar.contents = {
    TAG: /* Linkto */1,
    _0: t1$p
  };
  return t1$p;
}

function unify(_t1, _t2) {
  while(true) {
    var t2 = _t2;
    var t1 = _t1;
    var t1$p = repr_type(t1);
    var t2$p = repr_type(t2);
    if (t1$p === t2$p) {
      return ;
    }
    var exit = 0;
    var tvar;
    var t;
    var exit$1 = 0;
    if (typeof t1$p === "number") {
      if (t1$p === /* TInt */0) {
        if (typeof t2$p === "number") {
          if (t2$p === /* TInt */0) {
            return ;
          }
          exit = 1;
        } else if (t2$p.TAG === /* TVar */0) {
          exit$1 = 3;
        } else {
          exit = 1;
        }
      } else if (typeof t2$p === "number") {
        if (t2$p === /* TBool */1) {
          return ;
        }
        exit = 1;
      } else if (t2$p.TAG === /* TVar */0) {
        exit$1 = 3;
      } else {
        exit = 1;
      }
    } else {
      switch (t1$p.TAG | 0) {
        case /* TVar */0 :
            tvar = t1$p._0;
            t = t2$p;
            exit = 2;
            break;
        case /* TArr */1 :
            if (typeof t2$p === "number") {
              exit = 1;
            } else {
              switch (t2$p.TAG | 0) {
                case /* TVar */0 :
                    exit$1 = 3;
                    break;
                case /* TArr */1 :
                    unify(t1$p._0, t2$p._0);
                    _t2 = t2$p._1;
                    _t1 = t1$p._1;
                    continue ;
                default:
                  exit = 1;
              }
            }
            break;
        case /* QVar */2 :
            exit$1 = 3;
            break;
        
      }
    }
    if (exit$1 === 3) {
      if (typeof t2$p === "number" || t2$p.TAG !== /* TVar */0) {
        exit = 1;
      } else {
        tvar = t2$p._0;
        t = t1$p;
        exit = 2;
      }
    }
    switch (exit) {
      case 1 :
          console.log("Wrong constraint : (" + toString(t1$p) + "," + toString(t2$p) + ")");
          throw {
                RE_EXN_ID: "Assert_failure",
                _1: [
                  "LetPoly.res",
                  118,
                  10
                ],
                Error: new Error()
              };
      case 2 :
          if (occurs(tvar, t)) {
            console.log("Can't solve these constraints");
            throw {
                  RE_EXN_ID: "Assert_failure",
                  _1: [
                    "LetPoly.res",
                    112,
                    12
                  ],
                  Error: new Error()
                };
          }
          tvar.contents = {
            TAG: /* Linkto */1,
            _0: t
          };
          return ;
      
    }
  };
}

function toStringSubst(s) {
  var mapDictToString = function (d) {
    return d[0] + " |-> " + toString(d[1]);
  };
  if (s) {
    return List.fold_left((function (a, b) {
                  return a + "," + mapDictToString(b);
                }), mapDictToString(s.hd), s.tl);
  } else {
    return "";
  }
}

function map_definition(p) {
  var x = p[1];
  if (typeof x === "number") {
    return ;
  }
  if (x.TAG !== /* TVar */0) {
    return ;
  }
  var xs = x._0.contents;
  if (xs.TAG === /* Nolink */0) {
    return xs._0;
  }
  
}

function free_tvars_in_ctx(ctx) {
  var get_tvar_nolink_in_typ = function (_t) {
    while(true) {
      var t = _t;
      if (typeof t === "number") {
        return /* [] */0;
      }
      switch (t.TAG | 0) {
        case /* TVar */0 :
            var xs = t._0.contents;
            if (xs.TAG === /* Nolink */0) {
              return {
                      hd: xs._0,
                      tl: /* [] */0
                    };
            }
            _t = xs._0;
            continue ;
        case /* TArr */1 :
            return Belt_List.concatMany([
                        get_tvar_nolink_in_typ(t._0),
                        get_tvar_nolink_in_typ(t._1)
                      ]);
        case /* QVar */2 :
            throw {
                  RE_EXN_ID: "Assert_failure",
                  _1: [
                    "LetPoly.res",
                    160,
                    19
                  ],
                  Error: new Error()
                };
        
      }
    };
  };
  var getKey = function (p) {
    return p[1];
  };
  var tvar_nolink = Belt_SetString.fromArray(Belt_Array.concatMany(Belt_List.toArray(Belt_List.map(ctx, (function (p) {
                      return Belt_List.toArray(get_tvar_nolink_in_typ(getKey(p)));
                    })))));
  var tvar_definitions = Belt_SetString.fromArray(Belt_List.toArray(Belt_List.keepMap(ctx, map_definition)));
  return Belt_SetString.toList(Belt_SetString.diff(tvar_nolink, tvar_definitions));
}

function gen(ty, ctx) {
  var freetvars = free_tvars_in_ctx(ctx);
  var go = function (ty, subst) {
    if (typeof ty === "number") {
      return [
              ty,
              subst
            ];
    }
    switch (ty.TAG | 0) {
      case /* TVar */0 :
          var xs = ty._0.contents;
          if (xs.TAG === /* Nolink */0) {
            var xs$1 = xs._0;
            var qt = Belt_List.getAssoc(subst, xs$1, (function (a, b) {
                    return a === b;
                  }));
            if (qt !== undefined) {
              return [
                      qt,
                      subst
                    ];
            } else if (Belt_List.has(Belt_List.keepMap(ctx, map_definition), xs$1, (function (a, b) {
                      return a === b;
                    }))) {
              return [
                      ty,
                      subst
                    ];
            } else {
              return [
                      {
                        TAG: /* QVar */2,
                        _0: xs$1
                      },
                      {
                        hd: [
                          xs$1,
                          {
                            TAG: /* QVar */2,
                            _0: xs$1
                          }
                        ],
                        tl: subst
                      }
                    ];
            }
          }
          var match = go(xs._0, subst);
          return [
                  {
                    TAG: /* TVar */0,
                    _0: {
                      contents: {
                        TAG: /* Linkto */1,
                        _0: match[0]
                      }
                    }
                  },
                  match[1]
                ];
      case /* TArr */1 :
          var match$1 = go(ty._0, subst);
          var match$2 = go(ty._1, match$1[1]);
          return [
                  {
                    TAG: /* TArr */1,
                    _0: match$1[0],
                    _1: match$2[0]
                  },
                  match$2[1]
                ];
      case /* QVar */2 :
          throw {
                RE_EXN_ID: "Assert_failure",
                _1: [
                  "LetPoly.res",
                  207,
                  19
                ],
                Error: new Error()
              };
      
    }
  };
  return go(ty, Belt_List.map(freetvars, (function (x) {
                      return [
                              x,
                              {
                                TAG: /* QVar */2,
                                _0: x
                              }
                            ];
                    })))[0];
}

function check_expr(ctx, expr) {
  switch (expr.TAG | 0) {
    case /* CstI */0 :
        return /* TInt */0;
    case /* CstB */1 :
        return /* TBool */1;
    case /* Var */2 :
        var ts = Belt_List.getAssoc(ctx, expr._0, (function (a, b) {
                return a === b;
              }));
        if (ts !== undefined) {
          return inst(ts);
        }
        throw {
              RE_EXN_ID: "Assert_failure",
              _1: [
                "LetPoly.res",
                220,
                15
              ],
              Error: new Error()
            };
    case /* If */3 :
        var tx = {
          TAG: /* TVar */0,
          _0: fresh_name(undefined)
        };
        var t1 = check_expr(ctx, expr._0);
        var t2 = check_expr(ctx, expr._1);
        var t3 = check_expr(ctx, expr._2);
        unify(t1, /* TBool */1);
        unify(t2, tx);
        unify(t3, tx);
        return tx;
    case /* Add */4 :
        var tx$1 = {
          TAG: /* TVar */0,
          _0: fresh_name(undefined)
        };
        var t1$1 = check_expr(ctx, expr._0);
        var t2$1 = check_expr(ctx, expr._1);
        unify(tx$1, /* TInt */0);
        unify(t1$1, /* TInt */0);
        unify(t2$1, /* TInt */0);
        return tx$1;
    case /* Fun */5 :
        var tx$2 = {
          TAG: /* TVar */0,
          _0: fresh_name(undefined)
        };
        var te = check_expr({
              hd: [
                expr._0,
                tx$2
              ],
              tl: ctx
            }, expr._1);
        return {
                TAG: /* TArr */1,
                _0: tx$2,
                _1: te
              };
    case /* App */6 :
        var tx$3 = {
          TAG: /* TVar */0,
          _0: fresh_name(undefined)
        };
        var t1$2 = check_expr(ctx, expr._0);
        var t2$2 = check_expr(ctx, expr._1);
        unify(t1$2, {
              TAG: /* TArr */1,
              _0: t2$2,
              _1: tx$3
            });
        return tx$3;
    case /* Let */7 :
        var t1$3 = check_expr(ctx, expr._1);
        var ctx$p_0 = [
          expr._0,
          gen(t1$3, ctx)
        ];
        var ctx$p = {
          hd: ctx$p_0,
          tl: ctx
        };
        var t2$3 = check_expr(ctx$p, expr._2);
        console.log(toStringSubst(ctx$p));
        return t2$3;
    
  }
}

function infer(expr) {
  return check_expr(/* [] */0, expr);
}

var test = {
  TAG: /* Let */7,
  _0: "h",
  _1: {
    TAG: /* Fun */5,
    _0: "f",
    _1: {
      TAG: /* Let */7,
      _0: "g",
      _1: {
        TAG: /* Var */2,
        _0: "f"
      },
      _2: {
        TAG: /* Var */2,
        _0: "g"
      }
    }
  },
  _2: {
    TAG: /* If */3,
    _0: {
      TAG: /* App */6,
      _0: {
        TAG: /* Var */2,
        _0: "h"
      },
      _1: {
        TAG: /* CstB */1,
        _0: true
      }
    },
    _1: {
      TAG: /* App */6,
      _0: {
        TAG: /* Var */2,
        _0: "h"
      },
      _1: {
        TAG: /* CstI */0,
        _0: 1
      }
    },
    _2: {
      TAG: /* App */6,
      _0: {
        TAG: /* Var */2,
        _0: "h"
      },
      _1: {
        TAG: /* CstI */0,
        _0: 0
      }
    }
  }
};

var inferred = check_expr(/* [] */0, test);

console.log(toString(inferred));

var LetPoly = {
  toString: toString,
  tvar_cnt: tvar_cnt,
  fresh_name: fresh_name,
  new_tvar: new_tvar,
  inst_map: inst_map,
  fresh_inst: fresh_inst,
  new_inst: new_inst,
  inst: inst,
  occurs: occurs,
  repr_type: repr_type,
  unify: unify,
  toStringSubst: toStringSubst,
  map_definition: map_definition,
  free_tvars_in_ctx: free_tvars_in_ctx,
  gen: gen,
  check_expr: check_expr,
  infer: infer,
  test: test,
  inferred: inferred
};

exports.LetPoly = LetPoly;
/* inferred Not a pure module */
