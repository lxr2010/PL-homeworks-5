// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var List = require("rescript/lib/js/list.js");
var Caml_obj = require("rescript/lib/js/caml_obj.js");
var Belt_List = require("rescript/lib/js/belt_List.js");

function toString(t) {
  if (typeof t === "number") {
    if (t === /* TInt */0) {
      return "Int";
    } else {
      return "Bool";
    }
  } else if (t.TAG === /* TVar */0) {
    return "T_" + t._0;
  } else {
    return "( " + toString(t._0) + " -> " + toString(t._1) + " )";
  }
}

var tvar_cnt = {
  contents: 0
};

function new_tvar(param) {
  tvar_cnt.contents = tvar_cnt.contents + 1 | 0;
  return {
          TAG: /* TVar */0,
          _0: "@*" + tvar_cnt.contents.toString()
        };
}

function toStringCstr(cs) {
  var mapDictToString = function (d) {
    return "(" + toString(d[0]) + "," + toString(d[1]) + ")";
  };
  if (cs) {
    return List.fold_left((function (a, b) {
                  return a + ";" + mapDictToString(b);
                }), mapDictToString(cs.hd), cs.tl);
  } else {
    return "";
  }
}

function toStringSubst(s) {
  var mapDictToString = function (d) {
    return toString({
                TAG: /* TVar */0,
                _0: d[0]
              }) + " |-> " + toString(d[1]);
  };
  if (s) {
    return List.fold_left((function (a, b) {
                  return a + "," + mapDictToString(b);
                }), mapDictToString(s.hd), s.tl);
  } else {
    return "";
  }
}

function check_expr(ctx, expr) {
  switch (expr.TAG | 0) {
    case /* CstI */0 :
        return [
                /* TInt */0,
                /* [] */0
              ];
    case /* CstB */1 :
        return [
                /* TBool */1,
                /* [] */0
              ];
    case /* Var */2 :
        var ts = Belt_List.getAssoc(ctx, expr._0, (function (a, b) {
                return a === b;
              }));
        if (ts !== undefined) {
          return [
                  ts,
                  /* [] */0
                ];
        }
        throw {
              RE_EXN_ID: "Assert_failure",
              _1: [
                "Stlc.res",
                54,
                15
              ],
              Error: new Error()
            };
    case /* If */3 :
        var tx = new_tvar(undefined);
        var match = check_expr(ctx, expr._0);
        var match$1 = check_expr(ctx, expr._1);
        var match$2 = check_expr(ctx, expr._2);
        return [
                tx,
                Belt_List.concatMany([
                      match[1],
                      match$1[1],
                      match$2[1],
                      {
                        hd: [
                          match[0],
                          /* TBool */1
                        ],
                        tl: {
                          hd: [
                            match$1[0],
                            tx
                          ],
                          tl: {
                            hd: [
                              match$2[0],
                              tx
                            ],
                            tl: /* [] */0
                          }
                        }
                      }
                    ])
              ];
    case /* Fun */4 :
        var tx$1 = new_tvar(undefined);
        var match$3 = check_expr({
              hd: [
                expr._0,
                tx$1
              ],
              tl: ctx
            }, expr._1);
        return [
                {
                  TAG: /* TArr */1,
                  _0: tx$1,
                  _1: match$3[0]
                },
                match$3[1]
              ];
    case /* App */5 :
        var tx$2 = new_tvar(undefined);
        var match$4 = check_expr(ctx, expr._0);
        var match$5 = check_expr(ctx, expr._1);
        return [
                tx$2,
                Belt_List.concatMany([
                      match$4[1],
                      match$5[1],
                      {
                        hd: [
                          match$4[0],
                          {
                            TAG: /* TArr */1,
                            _0: match$5[0],
                            _1: tx$2
                          }
                        ],
                        tl: /* [] */0
                      }
                    ])
              ];
    case /* Add */6 :
        var tx$3 = new_tvar(undefined);
        var match$6 = check_expr(ctx, expr._0);
        var match$7 = check_expr(ctx, expr._1);
        return [
                tx$3,
                Belt_List.concatMany([
                      match$6[1],
                      match$7[1],
                      {
                        hd: [
                          tx$3,
                          /* TInt */0
                        ],
                        tl: {
                          hd: [
                            match$6[0],
                            /* TInt */0
                          ],
                          tl: {
                            hd: [
                              match$7[0],
                              /* TInt */0
                            ],
                            tl: /* [] */0
                          }
                        }
                      }
                    ])
              ];
    
  }
}

function occurs(x, _t) {
  while(true) {
    var t = _t;
    if (typeof t === "number") {
      return false;
    }
    if (t.TAG === /* TVar */0) {
      return t._0 === x;
    }
    if (occurs(x, t._0)) {
      return true;
    }
    _t = t._1;
    continue ;
  };
}

function tvar_subst(x, s, t) {
  if (typeof s === "number") {
    return s;
  } else if (s.TAG === /* TVar */0) {
    if (s._0 === x) {
      return t;
    } else {
      return s;
    }
  } else {
    return {
            TAG: /* TArr */1,
            _0: tvar_subst(x, s._0, t),
            _1: tvar_subst(x, s._1, t)
          };
  }
}

function tvar_list_subst(x, r, t) {
  var mapDict = function (d) {
    return [
            tvar_subst(x, d[0], t),
            tvar_subst(x, d[1], t)
          ];
  };
  var sameKeyVal = function (d) {
    return Caml_obj.equal(d[0], d[1]);
  };
  return Belt_List.keep(Belt_List.map(r, mapDict), (function (a) {
                return !sameKeyVal(a);
              }));
}

function solve(cs) {
  var _cs = cs;
  var _s = /* [] */0;
  while(true) {
    var s = _s;
    var cs$1 = _cs;
    if (!cs$1) {
      return s;
    }
    var rest = cs$1.tl;
    var c = cs$1.hd;
    var x;
    var t;
    var x$1 = c[0];
    var exit = 0;
    if (typeof x$1 === "number") {
      if (x$1 === /* TInt */0) {
        var tmp = c[1];
        if (typeof tmp === "number") {
          if (tmp === /* TInt */0) {
            _cs = rest;
            continue ;
          }
          exit = 3;
        } else {
          exit = tmp.TAG === /* TVar */0 ? 2 : 3;
        }
      } else {
        var tmp$1 = c[1];
        if (typeof tmp$1 === "number") {
          if (tmp$1 === /* TInt */0) {
            exit = 3;
          } else {
            _cs = rest;
            continue ;
          }
        } else {
          exit = tmp$1.TAG === /* TVar */0 ? 2 : 3;
        }
      }
    } else if (x$1.TAG === /* TVar */0) {
      x = x$1._0;
      t = c[1];
    } else {
      var match = c[1];
      if (typeof match === "number") {
        exit = 3;
      } else if (match.TAG === /* TVar */0) {
        exit = 2;
      } else {
        _cs = {
          hd: [
            x$1._0,
            match._0
          ],
          tl: {
            hd: [
              x$1._1,
              match._1
            ],
            tl: rest
          }
        };
        continue ;
      }
    }
    switch (exit) {
      case 2 :
          x = c[1]._0;
          t = x$1;
          break;
      case 3 :
          console.log("Wrong type constraint:" + toStringCstr({
                    hd: c,
                    tl: /* [] */0
                  }));
          throw {
                RE_EXN_ID: "Assert_failure",
                _1: [
                  "Stlc.res",
                  128,
                  12
                ],
                Error: new Error()
              };
      
    }
    if (occurs(x, t)) {
      console.log("Can't resolve these constraints.");
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "Stlc.res",
              122,
              14
            ],
            Error: new Error()
          };
    }
    _s = {
      hd: [
        x,
        t
      ],
      tl: s
    };
    _cs = tvar_list_subst(x, rest, t);
    continue ;
  };
}

function type_subst(t, s) {
  var real_type = function (_t, s) {
    while(true) {
      var t = _t;
      if (typeof t === "number") {
        return t;
      }
      if (t.TAG !== /* TVar */0) {
        return {
                TAG: /* TArr */1,
                _0: real_type(t._0, s),
                _1: real_type(t._1, s)
              };
      }
      var tx = Belt_List.getAssoc(s, t._0, (function (a, b) {
              return a === b;
            }));
      if (tx === undefined) {
        return t;
      }
      _t = tx;
      continue ;
    };
  };
  var mapDict = function (d) {
    return [
            d[0],
            real_type(d[1], s)
          ];
  };
  var s_reduced = Belt_List.map(s, mapDict);
  var go = function (t) {
    if (typeof t === "number") {
      return t;
    } else if (t.TAG === /* TVar */0) {
      var x = t._0;
      var tx = Belt_List.getAssoc(s_reduced, x, (function (a, b) {
              return a === b;
            }));
      if (tx !== undefined) {
        return tx;
      } else {
        return {
                TAG: /* TVar */0,
                _0: x
              };
      }
    } else {
      return {
              TAG: /* TArr */1,
              _0: go(t._0),
              _1: go(t._1)
            };
    }
  };
  return go(t);
}

function infer(expr) {
  var match = check_expr(/* [] */0, expr);
  var s = solve(match[1]);
  return type_subst(match[0], s);
}

var test = {
  TAG: /* Fun */4,
  _0: "f",
  _1: {
    TAG: /* Fun */4,
    _0: "a",
    _1: {
      TAG: /* Fun */4,
      _0: "b",
      _1: {
        TAG: /* If */3,
        _0: {
          TAG: /* Var */2,
          _0: "a"
        },
        _1: {
          TAG: /* Add */6,
          _0: {
            TAG: /* App */5,
            _0: {
              TAG: /* Var */2,
              _0: "f"
            },
            _1: {
              TAG: /* Var */2,
              _0: "b"
            }
          },
          _1: {
            TAG: /* CstI */0,
            _0: 1
          }
        },
        _2: {
          TAG: /* App */5,
          _0: {
            TAG: /* Var */2,
            _0: "f"
          },
          _1: {
            TAG: /* Var */2,
            _0: "a"
          }
        }
      }
    }
  }
};

var inferred = infer(test);

console.log(toString(inferred));

var Stlc = {
  toString: toString,
  tvar_cnt: tvar_cnt,
  new_tvar: new_tvar,
  toStringCstr: toStringCstr,
  toStringSubst: toStringSubst,
  check_expr: check_expr,
  occurs: occurs,
  tvar_subst: tvar_subst,
  tvar_list_subst: tvar_list_subst,
  solve: solve,
  type_subst: type_subst,
  infer: infer,
  test: test,
  inferred: inferred
};

function toString$1(_t) {
  while(true) {
    var t = _t;
    if (typeof t === "number") {
      if (t === /* TInt */0) {
        return "Int";
      } else {
        return "Bool";
      }
    }
    if (t.TAG !== /* TVar */0) {
      return "( " + toString$1(t._0) + " -> " + toString$1(t._1) + " )";
    }
    var sx = t._0.contents;
    if (sx.TAG === /* Nolink */0) {
      return "T_" + sx._0;
    }
    _t = sx._0;
    continue ;
  };
}

var tvar_cnt$1 = {
  contents: 0
};

function fresh_name(param) {
  tvar_cnt$1.contents = tvar_cnt$1.contents + 1 | 0;
  return {
          contents: {
            TAG: /* Nolink */0,
            _0: "@*" + tvar_cnt$1.contents.toString()
          }
        };
}

function new_tvar$1(param) {
  return {
          TAG: /* TVar */0,
          _0: fresh_name(undefined)
        };
}

function occurs$1(x, _t) {
  while(true) {
    var t = _t;
    if (typeof t === "number") {
      return false;
    }
    if (t.TAG === /* TVar */0) {
      var a = t._0;
      if (Caml_obj.equal(a.contents, x.contents)) {
        return true;
      }
      var t$p = a.contents;
      if (t$p.TAG === /* Nolink */0) {
        return false;
      }
      _t = t$p._0;
      continue ;
    }
    if (occurs$1(x, t._0)) {
      return true;
    }
    _t = t._1;
    continue ;
  };
}

function repr_type(t) {
  if (typeof t === "number") {
    return t;
  }
  if (t.TAG !== /* TVar */0) {
    return t;
  }
  var tvar = t._0;
  var t1 = tvar.contents;
  if (t1.TAG === /* Nolink */0) {
    return t;
  }
  var t1$p = repr_type(t1._0);
  tvar.contents = {
    TAG: /* Linkto */1,
    _0: t1$p
  };
  return t1$p;
}

function unify(_t1, _t2) {
  while(true) {
    var t2 = _t2;
    var t1 = _t1;
    var t1$p = repr_type(t1);
    var t2$p = repr_type(t2);
    if (t1$p === t2$p) {
      return ;
    }
    var exit = 0;
    var tvar;
    var t;
    if (typeof t1$p === "number") {
      if (t1$p === /* TInt */0) {
        if (typeof t2$p === "number") {
          if (t2$p === /* TInt */0) {
            return ;
          }
          exit = 1;
        } else if (t2$p.TAG === /* TVar */0) {
          tvar = t2$p._0;
          t = t1$p;
          exit = 2;
        } else {
          exit = 1;
        }
      } else if (typeof t2$p === "number") {
        if (t2$p !== /* TInt */0) {
          return ;
        }
        exit = 1;
      } else if (t2$p.TAG === /* TVar */0) {
        tvar = t2$p._0;
        t = t1$p;
        exit = 2;
      } else {
        exit = 1;
      }
    } else if (t1$p.TAG === /* TVar */0) {
      tvar = t1$p._0;
      t = t2$p;
      exit = 2;
    } else if (typeof t2$p === "number") {
      exit = 1;
    } else if (t2$p.TAG === /* TVar */0) {
      tvar = t2$p._0;
      t = t1$p;
      exit = 2;
    } else {
      unify(t1$p._0, t2$p._0);
      _t2 = t2$p._1;
      _t1 = t1$p._1;
      continue ;
    }
    switch (exit) {
      case 1 :
          console.log("Wrong constraint : (" + toString$1(t1$p) + "," + toString$1(t2$p) + ")");
          throw {
                RE_EXN_ID: "Assert_failure",
                _1: [
                  "Stlc.res",
                  253,
                  10
                ],
                Error: new Error()
              };
      case 2 :
          if (occurs$1(tvar, t)) {
            console.log("Can't solve these constraints");
            throw {
                  RE_EXN_ID: "Assert_failure",
                  _1: [
                    "Stlc.res",
                    247,
                    12
                  ],
                  Error: new Error()
                };
          }
          tvar.contents = {
            TAG: /* Linkto */1,
            _0: t
          };
          return ;
      
    }
  };
}

function check_expr$1(ctx, expr) {
  switch (expr.TAG | 0) {
    case /* CstI */0 :
        return /* TInt */0;
    case /* CstB */1 :
        return /* TBool */1;
    case /* Var */2 :
        var ts = Belt_List.getAssoc(ctx, expr._0, (function (a, b) {
                return a === b;
              }));
        if (ts !== undefined) {
          return ts;
        }
        throw {
              RE_EXN_ID: "Assert_failure",
              _1: [
                "Stlc.res",
                267,
                15
              ],
              Error: new Error()
            };
    case /* If */3 :
        var tx = {
          TAG: /* TVar */0,
          _0: fresh_name(undefined)
        };
        var t1 = check_expr$1(ctx, expr._0);
        var t2 = check_expr$1(ctx, expr._1);
        var t3 = check_expr$1(ctx, expr._2);
        unify(t1, /* TBool */1);
        unify(t2, tx);
        unify(t3, tx);
        return tx;
    case /* Fun */4 :
        var tx$1 = {
          TAG: /* TVar */0,
          _0: fresh_name(undefined)
        };
        var te = check_expr$1({
              hd: [
                expr._0,
                tx$1
              ],
              tl: ctx
            }, expr._1);
        return {
                TAG: /* TArr */1,
                _0: tx$1,
                _1: te
              };
    case /* App */5 :
        var tx$2 = {
          TAG: /* TVar */0,
          _0: fresh_name(undefined)
        };
        var t1$1 = check_expr$1(ctx, expr._0);
        var t2$1 = check_expr$1(ctx, expr._1);
        unify(t1$1, {
              TAG: /* TArr */1,
              _0: t2$1,
              _1: tx$2
            });
        return tx$2;
    case /* Add */6 :
        var tx$3 = {
          TAG: /* TVar */0,
          _0: fresh_name(undefined)
        };
        var t1$2 = check_expr$1(ctx, expr._0);
        var t2$2 = check_expr$1(ctx, expr._1);
        unify(tx$3, /* TInt */0);
        unify(t1$2, /* TInt */0);
        unify(t2$2, /* TInt */0);
        return tx$3;
    
  }
}

function infer$1(expr) {
  return check_expr$1(/* [] */0, expr);
}

var test$1 = {
  TAG: /* Fun */4,
  _0: "f",
  _1: {
    TAG: /* Fun */4,
    _0: "a",
    _1: {
      TAG: /* Fun */4,
      _0: "b",
      _1: {
        TAG: /* If */3,
        _0: {
          TAG: /* Var */2,
          _0: "a"
        },
        _1: {
          TAG: /* App */5,
          _0: {
            TAG: /* Var */2,
            _0: "f"
          },
          _1: {
            TAG: /* Var */2,
            _0: "b"
          }
        },
        _2: {
          TAG: /* App */5,
          _0: {
            TAG: /* Var */2,
            _0: "f"
          },
          _1: {
            TAG: /* Var */2,
            _0: "a"
          }
        }
      }
    }
  }
};

var inferred$1 = check_expr$1(/* [] */0, test$1);

console.log(toString$1(inferred$1));

var StlcUF = {
  toString: toString$1,
  tvar_cnt: tvar_cnt$1,
  fresh_name: fresh_name,
  new_tvar: new_tvar$1,
  occurs: occurs$1,
  repr_type: repr_type,
  unify: unify,
  check_expr: check_expr$1,
  infer: infer$1,
  test: test$1,
  inferred: inferred$1
};

exports.Stlc = Stlc;
exports.StlcUF = StlcUF;
/* inferred Not a pure module */
